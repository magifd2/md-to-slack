#!/usr/bin/env node
/**
 * Markdown to Slack Block Kit Converter
 * * This script reads Markdown text from standard input,
 * * converts it to JSON format usable with the Slack Block Kit API, and writes it to standard output.
 * * Reference article: https://qiita.com/yhatt/items/ebe892f341ce03d6d23f
 * * Usage:
 * 1. Ensure Node.js and npm are installed.
 * 2. Run `npm install marked` to install dependencies.
 * 3. Execute like `cat your_markdown_file.md | node md-to-slack-block-kit.js`.
 */

const fs = require('fs');
const { marked } = require('marked');

/**
 * Parses marked inline tokens and converts them to Slack mrkdwn format.
 * Supports links, bold, italics, strikethrough, inline code, etc.
 * @param {marked.Token[]} tokens - Array of inline tokens generated by marked.
 * @returns {string} Formatted string in Slack mrkdwn format.
 */
function parseInline(tokens) {
    let text = '';
    if (!tokens) return '';

    for (const token of tokens) {
        switch (token.type) {
            case 'text':
                text += token.text;
                break;
            case 'link':
                text += `<${token.href}|${parseInline(token.tokens)}>`;
                break;
            case 'image':
                // It's safer to represent images as links within Section Blocks.
                text += `<${token.href}|${token.text}>`;
                break;
            case 'strong':
                text += `*${parseInline(token.tokens)}*`;
                break;
            case 'em':
                text += `_${parseInline(token.tokens)}_`;
                break;
            case 'del':
                text += `~${parseInline(token.tokens)}~`;
                break;
            case 'codespan':
                text += `\`${token.text}\``;
                break;
            case 'br':
                text += '\n';
                break;
            default:
                // For unsupported tokens, use the original text as is.
                text += token.raw || '';
        }
    }
    return text;
}

/**
 * Recursively parses nested list tokens and generates an indented mrkdwn string.
 * @param {marked.Tokens.List} listToken - marked list token.
 * @param {number} depth - Current nesting depth of the list.
 * @returns {string} Formatted list string in Slack mrkdwn format.
 */
function renderList(listToken, depth = 0) {
    const indent = '  '.repeat(depth);
    return listToken.items.map((item, index) => {
        const prefix = listToken.ordered ? `${listToken.start + index}. ` : 'â€¢ ';
        
        let textContent = '';
        let nestedListContent = '';

        for (const token of item.tokens) {
            if (token.type === 'list') {
                nestedListContent = renderList(token, depth + 1);
            } else {
                textContent += parseInline(token.tokens || [token]);
            }
        }
        return `${indent}${prefix}${textContent}${nestedListContent ? '\n' + nestedListContent : ''}`;
    }).join('\n');
}

/**
 * Extracts plain text without formatting from marked tokens.
 * @param {marked.Token[]} tokens - Array of tokens generated by marked.
 * @returns {string} Extracted plain text.
 */
function extractTextFromTokens(tokens) {
    if (!tokens) return '';
    return tokens.map(token => {
        if (token.type === 'text') return token.text;
        if (token.tokens) return extractTextFromTokens(token.tokens);
        return token.raw || '';
    }).join('');
}

/**
 * Generates a rich_text cell object for Slack table blocks.
 * @param {marked.Token[]} cellTokens - Marked tokens representing the cell content.
 * @param {boolean} [isHeader=false] - Whether it's a header cell. If true, text will be bold.
 * @returns {object} Slack rich_text cell object.
 */
function createRichTextCell(cellTokens, isHeader = false) {
    // rich_text has different formatting from mrkdwn, so only plain text is extracted here.
    // In the future, this could be extended to support rich_text formatting (e.g., links).
    const textContent = extractTextFromTokens(cellTokens);
    
    const textElement = {
        type: 'text',
        // If the cell text is empty, it causes an API error, so a half-width space is inserted.
        text: textContent.trim() || ' ',
    };

    if (isHeader) {
        textElement.style = { bold: true };
    }

    return {
        type: 'rich_text',
        elements: [{
            type: 'rich_text_section',
            elements: [textElement]
        }]
    };
}


/**
 * Converts a Markdown string to a Slack Block Kit JSON object.
 * @param {string} markdown - The Markdown string to convert.
 * @returns {object} Slack Block Kit JSON object { blocks: [...] }.
 */
function markdownToSlackBlocks(markdown) {
    const tokens = marked.lexer(markdown, { gfm: true, breaks: true });
    const blocks = [];

    for (const token of tokens) {
        switch (token.type) {
            case 'heading':
                blocks.push({
                    type: 'header',
                    text: {
                        type: 'plain_text',
                        text: parseInline(token.tokens),
                        emoji: true,
                    },
                });
                break;

            case 'list':
                blocks.push({
                    type: 'section',
                    text: {
                        type: 'mrkdwn',
                        text: renderList(token),
                    },
                });
                break;

            case 'paragraph':
                const paragraphText = parseInline(token.tokens);
                if (paragraphText.trim()) {
                    blocks.push({
                        type: 'section',
                        text: {
                            type: 'mrkdwn',
                            text: paragraphText,
                        },
                    });
                }
                break;

            case 'blockquote':
                const quoteContent = token.tokens.map(innerToken => {
                    switch (innerToken.type) {
                        case 'heading': return `*${parseInline(innerToken.tokens)}*`;
                        case 'paragraph': return parseInline(innerToken.tokens);
                        case 'list': return renderList(innerToken);
                        case 'code': return `\`\`\`${innerToken.lang || ''}\n${innerToken.text}\n\`\`\``;
                        default: return innerToken.raw;
                    }
                }).join('\n');
                const quoteText = quoteContent.split('\n').map(line => `> ${line}`).join('\n');
                blocks.push({
                    type: 'section',
                    text: {
                        type: 'mrkdwn',
                        text: quoteText,
                    },
                });
                break;

            case 'code':
                blocks.push({
                    type: 'section',
                    text: {
                        type: 'mrkdwn',
                        text: `\`\`\`${token.lang || ''}\n${token.text}\n\`\`\``,
                    },
                });
                break;

            case 'hr':
                blocks.push({ type: 'divider' });
                break;

            case 'image':
                blocks.push({
                    type: 'image',
                    image_url: token.href,
                    alt_text: token.text,
                    title: token.title ? { type: 'plain_text', text: token.title, emoji: true } : undefined,
                });
                break;
            
            case 'table':
                // Generate header row (bold)
                const headerRow = token.header.map(cell => createRichTextCell(cell.tokens, true));
                // Generate data rows
                const dataRows = token.rows.map(row => 
                    row.map(cell => createRichTextCell(cell.tokens, false))
                );

                blocks.push({
                    type: 'table',
                    rows: [headerRow, ...dataRows]
                });
                break;

            case 'space':
                // Ignore multiple newlines.
                break;

            default:
                // console.warn(`Unsupported token type: ${token.type}`);
                break;
        }
    }

    return {
        blocks: blocks,
    };
}


/**
 * Main process: Reads Markdown from standard input or a specified file, converts it, and writes to standard output.
 */
function main() {
    const args = process.argv.slice(2); // Exclude the first two elements (node, script name)

    if (args.includes('--help') || args.includes('-h')) {
        console.log(`
Usage: node md-to-slack-block-kit.js [options] [file]

Convert Markdown to Slack Block Kit JSON.

Options:
  -h, --help    Show this help message and exit.

Arguments:
  file          Path to a Markdown file. If not provided, reads from stdin.

Examples:
  cat your_markdown_file.md | node md-to-slack-block-kit.js
  node md-to-slack-block-kit.js your_markdown_file.md
`);
        process.exit(0);
    }

    let markdownInput = '';
    try {
        if (args.length > 0) {
            // If a file path is specified
            const filePath = args[0];
            markdownInput = fs.readFileSync(filePath, 'utf8');
        } else {
            // If reading from standard input
            markdownInput = fs.readFileSync(0, 'utf8');
        }

        if (!markdownInput.trim()) {
            // Do nothing if input is empty or only whitespace
            return;
        }

        const slackBlockKitJson = markdownToSlackBlocks(markdownInput);
        console.log(JSON.stringify(slackBlockKitJson, null, 2));
    } catch (error) {
        if (error.code === 'ENOENT') {
            console.error(`Error: File not found at ${args[0]}`);
        } else {
            console.error("An error occurred during Markdown processing:", error);
        }
        process.exit(1);
    }
}

if (require.main === module) {
    main();
}
